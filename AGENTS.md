# Lido V3 – Findings (non‑admin attack surface)

## 1. Vault owners can continue triggering validator withdrawals while the hub is paused
- **Details:** `VaultHub.triggerValidatorWithdrawals()` (`contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/VaultHub.sol:867-897`) lacks the `whenResumed` modifier that protects every other state‑changing vault operation. As a result, even after governance pauses the hub, any vault owner can still call this function to initiate EIP‑7002 withdrawals and move ether out of their validators. Because the helper ultimately calls `_triggerVaultValidatorWithdrawals` with arbitrary calldata/value, a malicious owner can bypass the emergency stop, continue draining beacon rewards, and undo the risk‑mitigation that pausing is supposed to provide.
- **Impact:** Medium – pausing can no longer freeze validator withdrawals, so a compromised vault owner can keep extracting collateral during an incident.
- **Recommendation:** Gate `triggerValidatorWithdrawals()` (and its internal helpers) with `whenResumed`, or explicitly document and enforce a separate allow‑list if this capability should remain during pauses.

## 2. Validator exit requests also ignore the pause switch
- **Details:** The helper that emits exit requests, `VaultHub.requestValidatorExit()` (`contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/VaultHub.sol:847-855`), is callable by any vault owner even when `PausableUntil` is engaged. This lets an attacker keep asking node operators to exit validators during an emergency stop, undermining the pause mechanism and potentially forcing exits when the protocol is trying to stabilize.
- **Impact:** Low/Medium – pause can no longer stop vault owners from spamming exit requests, which is often precisely what governance attempts to block during an outage.
- **Recommendation:** Add `whenResumed` (or another explicit gating mechanism) to `requestValidatorExit` so that the pause actually freezes all validator life‑cycle operations.

## 3. ERC‑20 sweeps from vaults are possible while paused
- **Details:** `VaultHub.collectERC20FromVault()` (`contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/VaultHub.sol:980-994`) lets a vault owner instruct the hub to transfer arbitrary ERC‑20 balances out of their StakingVault. The function has no `whenResumed` guard, so owners can still evacuate any ERC‑20 collateral or airdrops even when the pause switch is supposed to freeze movements.
- **Impact:** Low – a paused hub is expected to prevent value movement, but ERC‑20 assets can still be siphoned out, reducing the effectiveness of the emergency stop.
- **Recommendation:** Apply `whenResumed` to `collectERC20FromVault()` (and companion helpers) so that token sweeps are halted during pauses unless there is a strong reason to keep them active.

## 4. Vault factory can never complete `createVaultWithDashboard`
- **Details:** `Dashboard.connectToVaultHub()` refuses to run unless `isApprovedToConnect` is `true` (`contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/dashboard/Dashboard.sol:285-294`). The only function that flips this flag is `setApprovedToConnect`, which is gated by `NODE_OPERATOR_MANAGER_ROLE` (`contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/dashboard/NodeOperatorFee.sol:174-183`). When the factory deploys a new dashboard (`contracts/0x1d10DB6a66EF8D2A6f6D36Ad4dc7092Ef7C12569/contracts/0.8.25/vaults/VaultFactory.sol:90-110`), it immediately calls `dashboard.connectToVaultHub()` but never calls `setApprovedToConnect(true)` first, nor does it hold the node-operator-manager role (it is assigned to the user-supplied `_nodeOperatorManager` inside `dashboard.initialize`). Consequently the very first connect attempt always reverts with `ForbiddenToConnectByNodeOperator`, making `createVaultWithDashboard` unusable for any caller.
- **Impact:** High – the flagship factory method that should deploy and connect a vault simply cannot succeed, so automated onboarding of new vaults is blocked.
- **Recommendation:** Before invoking `connectToVaultHub`, the factory (while it still controls the dashboard) should flip the approval flag—e.g. temporarily assign itself `NODE_OPERATOR_MANAGER_ROLE`, call `setApprovedToConnect(true)`, run the connect, and only then transfer the role to the intended manager.

## 5. `_roleAssignments` break `createVaultWithDashboardWithoutConnecting`
- **Details:** In the “without connecting” branch the factory initializes the dashboard with `_defaultAdmin` set to the user and only keeps the temporary node-operator-manager role for itself (`contracts/0x1d10DB6a66EF8D2A6f6D36Ad4dc7092Ef7C12569/contracts/0.8.25/vaults/VaultFactory.sol:123-149`). Despite not being the default admin anymore, it immediately executes `dashboard.grantRoles(_roleAssignments)`. Every operational role (FUND/MINT/BURN/etc.) in `Permissions` keeps `DEFAULT_ADMIN_ROLE` as its admin (`contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/dashboard/Permissions.sol:150-190`), so the factory lacks the authority to grant them and the call reverts with `AccessControlUnauthorizedAccount` whenever `_roleAssignments` is non-empty. Users therefore cannot preconfigure operator permissions when using this factory path.
- **Impact:** Medium – the advertised `_roleAssignments` parameter is unusable in this mode, forcing deployers either to pass an empty list or watch the entire deployment revert.
- **Recommendation:** Delay `_roleAssignments` until the real default admin (the user) can execute them, or temporarily keep `DEFAULT_ADMIN_ROLE` on the factory contract until after the optional role grants are processed.

## 6. Dashboard fee calculation undercounts values quarantined by LazyOracle
- **Details:** `NodeOperatorFee._calculateFee()` (e.g., `contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/dashboard/NodeOperatorFee.sol:320-334`) computes growth as `latestReport.totalValue - inOutDelta`. This ignores the portion of total value currently withheld in the LazyOracle quarantine buffer, even though that value is already backed by validators and will eventually be released to the vault hub. As a result, when a vault accrues rewards large enough to be quarantined, the node operator fee base is temporarily understated and the operator can avoid paying fees on that quarantined increment until after it is released. The mismatch is observable because `LazyOracle.quarantineValue()` exposes the pending quarantined amount, yet `_calculateFee` never adds it.
- **Impact:** Medium – malcious or lucky vault operators can postpone (and possibly escape, depending on timing) the fee on quarantined rewards, reducing protocol revenue during high-MEV periods.
- **Recommendation:** Include the current quarantined amount in the total-value calculation (i.e., add `LazyOracle.quarantineValue(address(_stakingVault()))` to the value used for growth) so that fees accrue on rewards immediately, regardless of the quarantine state.

## 7. Node operator manager can arbitrarily erase accrued fees
- **Details:** `addFeeExemption` (`contracts/0xbf95Cd394cC03cD03fEA62A435ac347314877f1d/contracts/0.8.25/vaults/dashboard/NodeOperatorFee.sol:254-259`) lets any account with `NODE_OPERATOR_FEE_EXEMPT_ROLE` increase `settledGrowth` by an arbitrary amount via `_addFeeExemption`. Crucially, `_setRoleAdmin(NODE_OPERATOR_FEE_EXEMPT_ROLE, NODE_OPERATOR_MANAGER_ROLE)` and `_grantRole(NODE_OPERATOR_MANAGER_ROLE, _nodeOperatorManager)` are executed during initialization (`NodeOperatorFee.sol:126-140`), so the node operator manager (i.e., the very party that owes fees) can grant themselves the exemption role and call `addFeeExemption` at will. There is no linkage to actual deposits or PDG proofs, so they can repeatedly add large exemptions until `settledGrowth` catches up to or exceeds any positive growth, forcing `_calculateFee` to return zero indefinitely.
- **Impact:** High – a malicious node operator can self-award unlimited fee exemptions and permanently avoid paying protocol fees, defeating the entire fee mechanism.
- **Recommendation:** Restrict `NODE_OPERATOR_FEE_EXEMPT_ROLE` to governance-side addresses (or require dual confirmation) and enforce objective limits on `_amount` (e.g., matching PDG-proven deposits) before updating `settledGrowth`.

    *Practical abuse path:* the factory takes `_nodeOperatorManager` as a user-supplied parameter when deploying a dashboard, and that address instantly receives `NODE_OPERATOR_MANAGER_ROLE` (and therefore administers `NODE_OPERATOR_FEE_EXEMPT_ROLE`). The operator can self-grant the exemption role and invoke `addFeeExemption(amount)` with arbitrarily large values, as many times as desired. Each call increases `settledGrowth` with no cap or on-chain justification, so the operator keeps `settledGrowth ≥ growth` and `_calculateFee` always sees zero `unsettledGrowth`, meaning no protocol fees ever accrue despite real rewards. This lets the node operator deterministically wipe the fee base without any DAO approval.

## Note on Documentation vs Contract Enforcement
- DOC: "The Node Operator management address ... MUST BE SET UP AS A MULTISIG" (official docs).
- CODE: `VaultFactory.createVaultWithDashboard` accepts any `_nodeOperatorManager` without checks, and `NodeOperatorFee._initialize` only enforces non-zero before granting roles.
- So, multisig usage is advisory only; not enforced on-chain. Triager may consider this "governance" or "operational" and not accept as exploit.
